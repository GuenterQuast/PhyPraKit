
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PhyPraKit Documentation &#8212; PhyPraKit 1.1.3 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">PhyPraKit 1.1.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>PhyPraKit Documentation</strong></a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="phyprakit-documentation">
<h1><strong>PhyPraKit Documentation</strong><a class="headerlink" href="#phyprakit-documentation" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p><cite>Version</cite> 2021-03-19</p>
</div></blockquote>
<div class="section" id="about">
<h2>About<a class="headerlink" href="#about" title="Permalink to this headline">¶</a></h2>
<p><strong>PhyPraKit</strong> is a collection of python modules
for data visialisation and analysis in experimental laboratory
cources in physics, in use at the faculty of physics at
Karlsruhe Institute of Technology (KIT). As the modules are
intended primarily for use by undertraduate students in
Germany, the documentation is partly in German language,
in particular the desctiption of the examples.</p>
<p>Cerated by:</p>
<ul class="simple">
<li><p>Guenter Quast &lt;guenter (dot) quast (at) online (dot) de&gt;</p></li>
</ul>
<p>A pdf version of this documentation is available here: <a class="reference external" href="PhyPraKit.pdf">PhyPraKit.pdf</a>.</p>
<div class="section" id="installation">
<h3>Installation:<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h3>
<p>To use PhyPraKit, it is sufficient to place the the direcotory
<cite>PhyPraKit</cite> and all the files in it in the same directory as the
python scripts importing it.</p>
<p>Installation via <cite>pip</cite> is also supported. After Downloading, execute:</p>
<p><code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--user</span> <span class="pre">.</span></code></p>
<p>in the main directory of the <em>PhyPraKit</em> package (where <em>setup.py</em>
is located) to install in user space.</p>
<p>The installation <em>whl</em>-package in the subdirectory <cite>dist</cite> may also be used:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--user</span> <span class="pre">--no-cache</span> <span class="pre">PhyPraKit&lt;version&gt;.whl</span></code></p>
</div></blockquote>
<p>Installation via the PyPi Python Package Index is also available, simply
execute:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">--user</span> <span class="pre">PhyPraKit</span></code></p>
</div></blockquote>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p><strong>German Description:</strong></p>
<p><strong>PhyPraKit</strong> ist eine Sammlung nützlicher Funktionen in der Sprache
<cite>Python (&gt;=3.6, die meisten Module laufen auch noch mit der inzwischen
veralteten Verson 2.7)</cite> zum Aufnehmen, zur Bearbeitung,
Visualisierung und Auswertung von Daten in den physikalischen
Praktika. Die Anwendung der verschiedenen Funktionen des Pakets
werden jeweils durch Beispiele illustriert.</p>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
</div>
<div class="section" id="visualisation-and-analysis-of-measurement-data">
<h1><strong>Visualisation and Analysis of Measurement Data</strong><a class="headerlink" href="#visualisation-and-analysis-of-measurement-data" title="Permalink to this headline">¶</a></h1>
<p>Methods for recording, processing, visualization and analysis of
measurement data are required in all laboratory courses in Physics.</p>
<p>This collection of tools in the package <cite>PhyPraKit</cite> contains
functions for reading data from various sources, for data
visualization, signal processing and statistical data analyis and
model fitting as well as tools for generation of simulated data.
Emphasis was put on simple implementations, illustrating the
principles of the underlining coding.</p>
<p>The class <em>mFit</em> in the module <em>phyFit</em> offers a light-weight
implementation for fitting model functions to data with uncorrelated
and/or correlated absolute and/or relative uncertainties in ordinate
and/or abscissa directions. For such complex forms of uncertainties,
there are hardly any are easy-to-use program packages. Most of the
existing applications use presets aiming at providing a parametrization
of measurement data, whereby the validity of the parametrization is
assumed and the the parameter uncertainties are scaled so that the
data is well described. <em>PhyPraKit</em> offers adapted interfaces to the
fit modules in the package <em>scipy</em> (<em>optimize.curve_fit</em> and <em>ODR</em>)
to perform fits with a test of the validity of the hypothesis.
<em>PhyPraKit</em> also contains a simplified interface to the very
function-rich fitting package <em>kafe2</em> (or the outdated previous
version <em>kafe</em>).</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<blockquote>
<div><p><strong>German: Darstellung und Auswertung von Messdaten</strong></p>
</div></blockquote>
<p>In allen Praktika zur Physik werden Methoden zur Aufnahme,
Bearbeitung, Darstellung und Auswertung von Messdaten benötigt.</p>
<p>Die vorliegende Sammlung im Paket <cite>PhyPraKit</cite> enthält
Funktionen zum Einlesen von Daten aus diversen Quellen, zur
Datenvisualisierung, Signalbearbeitung und zur statistischen
Datenauswertung und Modellanpassung sowie Werkzeuge zur Erzeugung
simulierter Daten.
Dabei wurde absichtlich Wert auf eine einfache, die Prinzipien
unterstreichende Codierung gelegt und nicht der möglichst effizienten
bzw. allgemeinensten Implementierung der Vorzug gegeben.</p>
<p>Das Modul <em>phyFit</em> bietet mit der Klasse <em>mnFit</em> eine schlanke
Implementierung zur Anpassung von Modellfunktionen an Daten,
die mit unkorrelierten und/oder korrelierten absoluten
und/oder relativen Unsicherheiten in Ordinaten- und/oder
Abszissenrichtung behaftet sind.
Für solche in der Physik häufig auftretenden komplexen Formen von
Unsicherheiten gibt es kaum andere, einfach zu verwendende
Programmpakete. Andere Pakte sind meist als Voreinstellung auf
die Parametrisierung von Messdaten ausgelegt, wobei die
Parameterunsicherheiten unter Annahme der Gültigkeit der
Parametrisierung so skaliert werden, dass die Daten gut
repräsentiert werden. <em>PhyPraKit</em> bietet entsprechend angepasste
Interfaces zu den Fitmodulen im Paket <em>scipy</em>
(<em>optimize.curve_fit</em> und <em>ODR</em>), um Anpassungen mit Test der Gültigkeit
der Modellhypothese durchzuführen. <em>PhyPraKit</em> enthält ebenfalls ein
vereinfachtes Interface zum sehr funtkionsreichen Anpassungspaket
<em>kafe2</em> (oder zur mittlerweile veralteten Vorängerversion <em>kafe</em>).</p>
<p>In der Vorlesung “Computergestützte Datenauswertung” an der Fakultät
für Physik am Karlsruher Institut für Physik
(<a class="reference external" href="http://www.ekp.kit.edu/~quast/CgDA">http://www.ekp.kit.edu/~quast/CgDA</a>)
werden die in <em>PhyPraKit</em> verwendeten Methoden eingeführt und beschrieben.
Hinweise zur Installation der empfohlenen Software finden sich unter den Links
<a class="reference external" href="http://www.ekp.kit.edu/~quast/CgDA/CgDA-SoftwareInstallation-html">http://www.ekp.kit.edu/~quast/CgDA/CgDA-SoftwareInstallation-html</a> und
<a class="reference external" href="http://www.ekp.kit.edu/~quast/CgDA/CgDA-SoftwareInstallation.pdf">http://www.ekp.kit.edu/~quast/CgDA/CgDA-SoftwareInstallation.pdf</a></p>
<p>Speziell für das “Praktikum zur klassischen Physik” am KIT gibt es
eine  kurze Einführung in die statistischen Methoden und Werkzeuge
(<a class="reference external" href="http://www.ekp.kit.edu/~quast/CgDA/PhysPrakt/CgDA_APraktikum.pdf">http://www.ekp.kit.edu/~quast/CgDA/PhysPrakt/CgDA_APraktikum.pdf</a>).</p>
</div>
<div class="section" id="dokumentation-der-beispiele">
<h1>Dokumentation der Beispiele<a class="headerlink" href="#dokumentation-der-beispiele" title="Permalink to this headline">¶</a></h1>
<p><strong>`PhyPraKit.py`</strong> ist ein Paket mit nützlichen Hilfsfunktionen
zum import in eigene Beispiele mittels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">PhyPraKit</span> <span class="k">as</span> <span class="nn">ppk</span>
</pre></div>
</div>
<p>oder:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">PhyPraKit</span> <span class="kn">import</span> <span class="o">...</span>
</pre></div>
</div>
<p><strong>PhyPraKit</strong> enthält folgende <strong>Funktionen</strong>:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Daten-Ein und -Ausgabe</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>readColumnData() Daten und Meta-Daten aus Textdatei lesen</p></li>
<li><p>readCSV()        Daten im csv-Format aus Datei mit Header lesen</p></li>
<li><p>readtxt()        Daten im Text-Format aus Datei mit Header lesen</p></li>
<li><p>readPicoScope()  mit PicoScope exportierte Daten einlesen</p></li>
<li><p>readCassy()      mit CASSY im .txt-Format exportierte Dateien einlesen</p></li>
<li><p>labxParser()     mit CASSY im .labx-Format exportierte Dateien einlesen</p></li>
<li><p>writeCSV()       Daten csv-Format schreiben (optional mit Header)</p></li>
<li><p>writeTexTable()  Daten als LaTeX-Tabelle exportieren</p></li>
<li><p>round_to_error() Runden von Daten mit Präzision wie Unsicherheit</p></li>
<li><p>ustring()        korrekt gerundete Werte v +/- u als Text;
alternativ: der Datentyp <em>ufloat(v, u)</em> im Paket <em>uncertainties</em>
untertützt die korrekte Ausgabe von Werten <em>v</em> mit Unsicherheiten <em>u</em>.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>Signalprozessierung:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>offsetFilter()      Abziehen eines off-sets</p></li>
<li><p>meanFilter()        gleitender Mittelwert zur Glättung</p></li>
<li><p>resample()          Mitteln über n Datenwerte</p></li>
<li><p>simplePeakfinder()  Auffinden von Maxima (Peaks) und Minima
(<cite>Empfehlung: convolutionPeakfinder nutzen</cite>)</p></li>
<li><p>convolutionPeakfinder() Finden von  Maxima</p></li>
<li><p>convolutionEdgefinder() Finden von Kanten</p></li>
<li><p>Fourier_fft()       schnelle Fourier-Transformation (FFT)</p></li>
<li><p>FourierSpectrum()   Fourier-Transformation
<cite>(langsam, vorzugsweise FFT-Version nutzen)</cite></p></li>
<li><p>autocorrelate()     Autokorrelation eines Signals</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>Statistik:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>wmean()                  Berechnen des gewichteten Mittelwerts</p></li>
<li><p>BuildCovarianceMatrix()  Koravianzmatrix aus Einzelunsicherheiten</p></li>
<li><p>Cov2Cor()                Konversion Kovarianzmatrix -&gt; Korrelationsmatrix</p></li>
<li><p>Cor2Cov()                Konversion Korrelationsmatrix +
Unsicherheiten -&gt; Kovarianzmatrix</p></li>
<li><p>chi2prob()               Berechnung der chi^2-Wahrscheinlichkeit</p></li>
<li><p>propagatedError()        Numerische Fehlerfortpflanzung;
Hinweis: der Datentyp <em>ufloat(v, u)</em> im Paket <em>uncertainties</em>
untertützt Funktionen von Werten <em>v</em> mit Unsicherheiten <em>u</em> und
die korrekte Fehlerfortpflanzung</p></li>
<li><p>getModelError()          Numerische Fehlefortpflanzung für
parameterabhängige Funktionswerte</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>Histogramm:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>barstat()   statistisch Information aus Histogramm (Mittelwert,
Standardabweichung, Unsicherheit des Mittelwerts)</p></li>
<li><p>nhist()    Histogramm-Grafik mit np.historgram() und plt.bar()
<cite>(besser matplotlib.pyplot.hist() nutzen)</cite></p></li>
<li><p>histstat() statistische Information aus 1d-Histogram</p></li>
<li><p>nhist2d()  2d-Histogramm mit np.histrogram2d, plt.colormesh()
<cite>(besser matplotlib.pyplot.hist2d() nutzen)</cite></p></li>
<li><p>hist2dstat() statistische Information aus 2d-histogram</p></li>
<li><p>profile2d()  “profile plot” für 2d-Streudiagramm</p></li>
<li><p>chi2p_indep2d() chi^2-Test auf Unabhängigkeit zweier Variabler</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>Lineare Regression und Anpassen von Fuktionen:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>linRegression()    lineare Regression, y=ax+b, mit analytische Formel</p></li>
<li><p>linRegressionXY()  lineare Regression, y=ax+b, mit x- und y-Unsicherheiten
<code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">veraltet,</span> <span class="pre">`odFit`</span> <span class="pre">mit</span> <span class="pre">linearem</span> <span class="pre">Model</span> <span class="pre">verwenden</span></code></p></li>
<li><p>kRegression()      lineare Regression, y=ax+b, mit (korrelierten) x-
und y-Unsicherheiten
<code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">veraltet,</span> <span class="pre">`k2Fit`</span> <span class="pre">mit</span> <span class="pre">linearem</span> <span class="pre">Modell</span> <span class="pre">verwenden</span></code></p></li>
<li><p>odFit()            Funktionsanpassung mit x- und y-Unsicherheiten
(scipy ODR)</p></li>
<li><p>mFit()             Funktionsanpassung mit (korrelierten) x- und
y-Unsicherheiten mit <em>phyFit</em></p></li>
<li><p>kFit()             Funktionsanpassung mit (korrelierten) x- und
y-Unsicherheiten mit dem Pakte <em>kafe</em>, <code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">veraltet,</span> <span class="pre">`k2Fit`</span> <span class="pre">verwenden</span></code></p></li>
<li><p>k2Fit()            Funktionsanpassung mit (korrelierten) x- und
y-Unsicherheiten mit dem Paket <em>kafe2</em></p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="6">
<li><p>Erzeugung simulierter Daten mit MC-Methode:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>smearData()          Addieren von zufälligen Unsicherheiten auf Eingabedaten</p></li>
<li><p>generateXYdata()     Erzeugen simulierter Datenpunkte (x+Delta_x, y+Delta_y)</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<p>Die folgenden <strong>Beispiele</strong> illustrieren die Anwendung:</p>
<blockquote>
<div><ul class="simple">
<li><p><cite>test_readColumnData.py</cite> ist ein Beispiel zum
Einlesen von Spalten aus Textdateien; die zugehörigen
<em>Metadaten</em> können ebenfalls an das Script übergeben
werden und stehen so bei der Auswertung zur Verfügung.</p></li>
<li><p><cite>test_readtxt.py</cite> liest Ausgabedateien im allgemeinem <cite>.txt</cite>-Format;
ASCII-Sonderzeichen außer dem Spalten-Trenner werden ersetzt,
ebenso wie das deutsche Dezimalkomma durch den Dezimalpunkt</p></li>
<li><p><cite>test_readPicoScope.py</cite> liest Ausgabedateien von USB-Oszillographen
der Marke PicoScope im Format <cite>.csv</cite> oder <cite>.txt</cite>.</p></li>
<li><p><cite>test_labxParser.py</cite> liest Ausgabedateien von Leybold
CASSY im <cite>.labx</cite>-Format. Die Kopfzeilen und Daten von Messreihen
werden als Listen in <em>python</em> zur Verfügung gestellt.</p></li>
<li><p><cite>test_convolutionFilter.py</cite> liest die Datei <cite>Wellenform.csv</cite> und
bestimmt Maxima und fallende Flanken des Signals</p></li>
<li><p><cite>test_AutoCorrelation.py</cite> liest die Datei <cite>AudioData.csv</cite> und führt
eine Analyse der Autokorrelation zur Frequenzbestimmung durch.</p></li>
<li><p><cite>test_Fourier.py</cite> illustriert die Durchführung einer
Fourier-Transfomation eines periodischen Signals, das in
der PicoScope-Ausgabedatei <cite>Wellenform.csv</cite> enthalten ist.</p></li>
<li><p><cite>test_propagatedError.py</cite> illustriert die Anwendung von numerisch
berechneter Fehlerfortpflanzung und korrekter Rundung von Größen
mit Unsicherheit</p></li>
<li><p><cite>test_linRegression.py</cite> ist eine einfachere Version mit
<cite>python</cite>-Bordmitteln zur Anpassung einer Geraden an
Messdaten mit Fehlern in Ordinaten- und Abszissenrichtung.
Korrelierte Unsicherheiten werden nicht unterstützt.</p></li>
<li><p><cite>test_mFit</cite> dient zur Anpassung einer beliebigen Funktion an
Messdaten mit Fehlern in Ordinaten- und Abszissenrichtung und mit
allen Messpunkten gemeinsamen (d. h. korrelierten) relativen oder
absoluten systematischen Fehlern. Dazu wird das Paket imunit
verwendet, das den am CERN entwicklten Minimierer MINUIT nutzt.
Da die Kostenfunktion frei definiert und auch während der Anpassung
dynamisch aktualisiert werden kann, ist die Implementierung von
Parameter-abhängigen Unsicherheiten möglich. Ferner unterstützt
iminuit die Erzeugung und Darstellung von Profil-Likelihood-Kurven
und Konfidenzkonturen, die so mit mFit ebenfalls dargestellt
werden können.</p></li>
<li><p><cite>test_kFit.py</cite> ist mittlerweile veraltet und dient ebenfalls
zur Anpassung einer beliebigen Funktion an Messdaten mit Fehlern
in Ordinaten- und Abszissenrichtung und mit allen Messpunkten
gemeinsamen (d. h. korrelierten) relativen oder absoluten
systematischen Fehlern mit dem Paket <cite>kafe</cite>.</p></li>
<li><p><cite>test_k2Fit.py</cite> verwendet die Version <em>kafe2</em> zur Anpassung einer
Funktion an Messdaten mit unabhängigen oder korrelierten relativen oder
absoluten Unsicherheiten in Ordinaten- und Abszissenrichtung.</p></li>
<li><p><cite>test_simplek2Fit.py</cite> illustriert die Durchführung einer einfachen
linearen Regression mit <em>kafe2</em> mit einer minimalen Anzal eigener
Codezeilen.</p></li>
<li><p><cite>test_Histogram.py</cite> ist ein Beispiel zur Darstellung und
statistischen Auswertung von Häufigkeitsverteilungen (Histogrammen)
in ein oder zwei Dimensionen.</p></li>
<li><p><cite>test_generateXYata.py</cite> zeigt, wie man mit Hilfe von Zufallszahlen
“künstliche Daten” zur Veranschaulichung oder zum Test von Methoden
zur Datenauswertung erzeugen kann.</p></li>
<li><p><cite>toyMC_Fit.py</cite> führt eine große Anzahl Anpassungen an simulierte
Daten durch. Durch Vergleich der wahren Werte mit den aus der
Anpassung bestimmten Werten lassen sich Verzerrungen der
Parameterschätzungen oder die Form der Verteilung der
Chi2-Wahrscheinlichkeit überprüfen, die im Idealfall eine
Rechteckverteilung im Intervall [0,1] sein sollte.</p></li>
</ul>
<p>Die folgenden <em>python</em>-Skripte sind etwas komplexer und illustrieren
typische Anwendungsfälle der Module in <cite>PhyPraKit</cite>:</p>
<ul class="simple">
<li><p><cite>kfitf.py</cite> ist ein Kommandozeilen-Werkzeug, mit dem man komfortabel
Anpassungen ausführen kann, bei denen Daten und Fit-Funktion in
einer einzigen Datei angegeben werden. Beispiele finden sich
in den Dateien mit der Endung <cite>.fit</cite>.</p></li>
<li><p><cite>Beispiel_Diodenkennlinie.py</cite> demonstriert die Analyse einer
Strom-Spannungskennlinie am Beispiel von (künstlichen) Daten,
an die die Shockley-Gleichung angepasst wird. Typisch für
solche Messungen über einen weiten Bereich von Stromstärken
ist die Änderung des Messbereichs und damit der Anzeigegenauigkeit
des verwendeten Messgeräts. Im steil ansteigenden Teil der
Strom-Spannungskennlinie ist es außerdem wichtig, auch die Unsicherheit
der auf der x-Achse aufgetragen Spannungsmessungen zu berücksichtigen.
Eine weitere Komponente der Unsicherheit ergibt sich aus der
Kalibrationsgenauigkeit des Messgeräts, die als relative,
korrelierte Unsicherheit aller Messwerte berücksichtig weden
muss. Das Beispiel zeigt, wie man in diesem Fall die Kovarianzmatrix
aus Einzelunsicherheiten aufbaut. Die Funktionen <em>k2Fit()</em> und
<em>mfit()</em> bieten dazu komfortable und leicht zu verwendende
Interfaces, deren Anwendung zur Umsetzung des komplexen Fehlermodells
in diesem Beispiel gezeigt wird.</p></li>
<li><p><cite>Beispiel_Drehpendel.py</cite> demonstriert die Analyse von am Drehpendel
mit CASSY aufgenommenen Daten. Enthalten sind einfache Funktionen zum
Filtern und Bearbeiten der Daten, zur Suche nach Extrema und Anpassung
einer Einhüllenden, zur diskreten Fourier-Transformation und zur
Interpolation von Messdaten mit kubischen Spline-Funktionen.</p></li>
<li><p><cite>Beispiel_Hysterese.py</cite> demonstriert die Analyse von Daten,
die mit einem USB-Oszilloskop der Marke <cite>PicoScope</cite> am
Versuch zur Hysterese aufgenommen wurden. Die aufgezeichneten Werte
für Strom und B-Feld werden in einen Zweig für steigenden und
fallenden Strom aufgeteilt, mit Hilfe von kubischen Splines
interpoliert und dann integriert.</p></li>
<li><p><cite>Beispiel_Wellenform.py</cite>  zeigt eine typische Auswertung
periodischer Daten am Beispiel der akustischen Anregung eines
Metallstabs. Genutzt werden Fourier-Transformation und
eine Suche nach charakteristischen Extrema. Die Zeitdifferenzen
zwischen deren Auftreten im Muster werden bestimmt, als
Häufgkeitsverteilung dargestellt und die Verteilungen statistisch
ausgewertet.</p></li>
<li><p><cite>Beispiel_GammaSpektroskopie.py</cite> liest mit dem Vielkanalanalysator
des CASSY-Systems im <cite>.labx</cite> -Format gespeicherten Dateien ein
(Beispieldatei <cite>GammaSpektra.labx</cite>).</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="module-PhyPraKit">
<span id="module-documentation"></span><h1>Module Documentation<a class="headerlink" href="#module-PhyPraKit" title="Permalink to this headline">¶</a></h1>
<dl class="simple">
<dt><strong>PhyPraKit</strong>  </dt><dd><p>a collection of tools for data handling, visualisation and analysis 
in Physics Lab Courses, recommended for “Physikalisches Praktikum am KIT”</p>
</dd>
</dl>
<dl class="py function">
<dt id="PhyPraKit.A0_readme">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">A0_readme</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.A0_readme" title="Permalink to this definition">¶</a></dt>
<dd><p>Package PhyPrakit</p>
<p><strong>PhyPraKit</strong>  for Data Handling, Visualisation and Analysis</p>
<p>contains the following functions:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Data input:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>readColumnData() read data and meta-data from text file</p></li>
<li><p>readCSV()        read data in csv-format from file with header</p></li>
<li><p>readtxt()        read data in “txt”-format from file with header</p></li>
<li><p>readPicoScope()  read data from PicoScope</p></li>
<li><p>readCassy()      read CASSY output file in .txt format</p></li>
<li><p>labxParser()     read CASSY output file, .labx format</p></li>
<li><p>writeCSV()       write data in csv-format (opt. with header)</p></li>
<li><p>writeTexTable()  write data in LaTeX table format</p></li>
<li><p>round_to_error() round to same number of sigfinicant digits as uncertainty</p></li>
<li><p>ustring()        return rounded value +/- uncertainty as formatted string;   
alternative: the data type <em>ufloat(v,u)</em> of packge <em>uncertainties</em> comfortably 
supports printing of values <em>v</em> with uncertainties <em>u</em>.</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>signal processing:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>offsetFilter()      subtract an offset in array a</p></li>
<li><p>meanFilter()        apply sliding average to smoothen data</p></li>
<li><p>resample()          average over n samples</p></li>
<li><p>simplePeakfinder()  find peaks and dips in an array,    
<cite>(recommend to use convolutionPeakfinder)</cite></p></li>
<li><p>convolutionPeakfinder() find maxima (peaks) in an array</p></li>
<li><p>convolutionEdgefinder() find maxima of slope (rising) edges in an array</p></li>
<li><p>Fourier_fft()       fast Fourier transformation of an array</p></li>
<li><p>FourierSpectrum()   Fourier transformation of an array   
<cite>(slow, preferably use fft version)</cite></p></li>
<li><p>autocorrelate()     autocorrelation function</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>statistics:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>wmean                  calculate weighted mean</p></li>
<li><p>BuildCovarianceMatrix  build coraviance matrix from individual uncertainties</p></li>
<li><p>Cov2Cor                convert covariance matrix to correlation matrix</p></li>
<li><p>Cor2Cov                convert correlation matrix + errors to covariance matrix</p></li>
<li><p>chi2prob               caclulate chi^2 probability</p></li>
<li><p>propagatedError        determine propageted uncertainty, with covariance;  
hint: the data type <em>ufloat(v,u)</em> of packge <em>uncertainties</em> comfortably supports 
functions of values <em>v</em> with uncertainties <em>u</em> with correct error propagation</p></li>
<li><p>getModelError          determine uncertainty of parameter-depenent model function</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="4">
<li><p>histograms tools:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>barstat()   statistical information (mean, sigma, error_on_mean) from bar chart</p></li>
<li><p>nhist()    histogram plot based on np.historgram() and plt.bar()    
<cite>better use matplotlib.pyplot.hist()</cite></p></li>
<li><p>histstat() statistical information from 1d-histogram</p></li>
<li><p>nhist2d()  2d-histotram plot based on np.histrogram2d, plt.colormesh()  
<cite>(better use matplotlib.pyplot.hist2d)</cite></p></li>
<li><p>hist2dstat() statistical information from 2d-histogram</p></li>
<li><p>profile2d()  “profile plot” for 2d data</p></li>
<li><p>chi2p_indep2d() chi2 test on independence of data</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li><p>linear regression and function fitting:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>linRegression()    linear regression, y=ax+b, with analytical formula</p></li>
<li><p>linRegressionXY()  linear regression, y=ax+b, with x and y errors  
<code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">deprecated,</span> <span class="pre">use</span> <span class="pre">`odFit`</span> <span class="pre">with</span> <span class="pre">linear</span> <span class="pre">model</span> <span class="pre">instead</span></code></p></li>
<li><p>kRegression()      linear regression, y=ax+b, with (correlated) 
errors on x, and y   
<code class="docutils literal notranslate"><span class="pre">!</span> <span class="pre">deprecated,</span> <span class="pre">consider</span> <span class="pre">using</span> <span class="pre">`k2Fit`</span> <span class="pre">with</span> <span class="pre">linear</span> <span class="pre">model</span> <span class="pre">instead</span></code></p></li>
<li><p>odFit()            fit function with x and y errors (scipy ODR)</p></li>
<li><p>mFit()             fit with with correlated x and y errors,
profile likelihood and contour lines (module phyFit)</p></li>
<li><p>kFit()             fit function with (correlated) errors on x and y 
(with package kafe, deprecated)</p></li>
<li><p>k2Fit()            fit function with (correlated) errors on x and y 
(with package kafe2)</p></li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="6">
<li><p>simulated data with MC-method:</p></li>
</ol>
<blockquote>
<div><ul class="simple">
<li><p>smearData()          add random deviations to input data</p></li>
<li><p>generateXYdata()     generate simulated data</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.BuildCovarianceMatrix">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">BuildCovarianceMatrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span></em>, <em class="sig-param"><span class="n">sigc</span><span class="o">=</span><span class="default_value">[]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.BuildCovarianceMatrix" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Construct a covariance matrix from independent and correlated error components</p>
</div></blockquote>
<dl class="simple">
<dt>Args: </dt><dd><ul class="simple">
<li><p>sig: iterable of independent errors</p></li>
<li><p>sigc: list of iterables of correlated uncertainties</p></li>
</ul>
</dd>
<dt>Returns: </dt><dd><p>covariance Matrix as numpy-array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.Cor2Cov">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">Cor2Cov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">sig</span></em>, <em class="sig-param"><span class="n">C</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.Cor2Cov" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convert a covariance-matrix into diagonal errors + Correlation matrix</p>
</div></blockquote>
<dl class="simple">
<dt>Args: </dt><dd><ul class="simple">
<li><p>sig: 1d numpy array of correlated uncertainties</p></li>
<li><p>C: correlation matrix as numpy array</p></li>
</ul>
</dd>
<dt>Returns: </dt><dd><ul class="simple">
<li><p>V: covariance matrix as numpy array</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.Cov2Cor">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">Cov2Cor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">V</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.Cov2Cor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Convert a covariance-matrix into diagonal errors + Correlation matrix</p>
</div></blockquote>
<dl class="simple">
<dt>Args: </dt><dd><ul class="simple">
<li><p>V: covariance matrix as numpy array</p></li>
</ul>
</dd>
<dt>Returns: </dt><dd><ul class="simple">
<li><p>diag uncertainties (sqrt of diagonal elements)</p></li>
<li><p>C: correlation matrix as numpy array</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.FourierSpectrum">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">FourierSpectrum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">fmax</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.FourierSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fourier transform of amplitude spectrum a(t), for equidistant sampling
times (a simple implementaion for didactical purpose only,
consider using <code class="docutils literal notranslate"><span class="pre">Fourier_fft()</span></code> )</p>
<blockquote>
<div><dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>t: np-array of time values</p></li>
<li><p>a: np-array amplidude a(t)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>arrays freq, amp: frequencies and amplitudes</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.Fourier_fft">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">Fourier_fft</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">t</span></em>, <em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.Fourier_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Fourier transform of the amplitude spectrum a(t)</p>
<dl>
<dt>method: </dt><dd><p>uses <cite>numpy.fft</cite> and <cite>numpy.fftfreq</cite>; 
output amplitude is normalised to number of samples;</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>t: np-array of time values</p></li>
<li><p>a: np-array amplidude a(t)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>arrays f, a_f: frequencies and amplitudes</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.autocorrelate">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">autocorrelate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.autocorrelate" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate autocorrelation function of input array</p>
<p>method: for array of length l, calculate 
a[0]=sum_(i=0)^(l-1) a[i]*[i] and 
a[i]= 1/a[0] * sum_(k=0)^(l-i) a[i] * a[i+k-1] for i=1,l-1</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>a: np-array</p></li>
</ul>
</dd>
<dt>Returns </dt><dd><ul class="simple">
<li><p>np-array of len(a), the autocorrelation function</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.barstat">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">barstat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">bincont</span></em>, <em class="sig-param"><span class="n">bincent</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.barstat" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics from a bar chart (histogram) 
with given bin contents and bin centres</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>bincont: array with bin content</p></li>
<li><p>bincent: array with bin centres</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: mean, sigma and sigma on mean</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.chi2p_indep2d">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">chi2p_indep2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">H2d</span></em>, <em class="sig-param"><span class="n">bcx</span></em>, <em class="sig-param"><span class="n">bcy</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.chi2p_indep2d" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a chi2-test on independence of x and y</p>
<p>method: chi2-test on compatibility of 2d-distribution, f(x,y),
with product of marginal distributions, f_x(x) * f_y(y)</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>H2d: histogram array (as returned by histogram2d)</p></li>
<li><p>bcx: bin contents x (marginal distribution x)</p></li>
<li><p>bcy: bin contents y (marginal distribution y)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: p-value w.r.t. assumption of independence</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.chi2prob">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">chi2prob</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chi2</span></em>, <em class="sig-param"><span class="n">ndf</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.chi2prob" title="Permalink to this definition">¶</a></dt>
<dd><p>chi2-probability</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>chi2: chi2 value</p></li>
<li><p>ndf: number of degrees of freedom</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: chi2 probability</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.convolutionEdgefinder">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">convolutionEdgefinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">th</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.convolutionEdgefinder" title="Permalink to this definition">¶</a></dt>
<dd><p>find positions of maximal positive slope in data</p>
<dl class="simple">
<dt>method: </dt><dd><p>convolute array <cite>a</cite> with an edge template of given width and
return extrema of convoluted signal, i.e. places of rising edges</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>a: array-like, input data</p></li>
<li><p>width: int, width of signal to search for</p></li>
<li><p>th: float, 0.&lt;= th &lt;=1., relative threshold above (global)minimum</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>pidx: list, indices (in original array) of rising edges</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.convolutionFilter">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">convolutionFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">th</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.convolutionFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>convolute normalized array with tmplate funtion and return maxima</p>
<dl class="simple">
<dt>method: </dt><dd><p>convolute array a with a template and return extrema of 
convoluted signal, i.e. places where template matches best</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>a: array-like, input data</p></li>
<li><p>a: array-like, template</p></li>
<li><p>th: float, 0.&lt;= th &lt;=1., relative threshold for places of
best match above (global) minimum</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>pidx: list, indices (in original array) of best matches</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.convolutionPeakfinder">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">convolutionPeakfinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">th</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.convolutionPeakfinder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>find positions of all Peaks in data </dt><dd><p>(simple version for didactical purpose, 
consider using <code class="docutils literal notranslate"><span class="pre">scipy.signal.find_peaks_cwt()</span></code> )</p>
</dd>
<dt>method: </dt><dd><p>convolute array a with rectangular template of given width and
return extrema of convoluted signal, i.e. places where 
template matches best</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>a: array-like, input data</p></li>
<li><p>width: int, width of signal to search for</p></li>
<li><p>th: float, 0.&lt;= th &lt;=1., relative threshold for peaks above (global)minimum</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>pidx: list, indices (in original array) of peaks</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.generateXYdata">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">generateXYdata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">xdata</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span></em>, <em class="sig-param"><span class="n">mpar</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srely</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.generateXYdata" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate measurement data according to some model
assumes xdata is measured within the given uncertainties; 
the model function is evaluated at the assumed “true” values 
xtrue, and a sample of simulated measurements is obtained by 
adding random deviations according to the uncertainties given 
as arguments.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>xdata:  np-array, x-data (independent data)</p></li>
<li><p>model: function that returns (true) model data (y-dat) for input x</p></li>
<li><p>mpar: list of parameters for model (if any)</p></li>
</ul>
</dd>
<dt>the following are single floats or arrays of length of x</dt><dd><ul class="simple">
<li><p>sx: gaussian uncertainty(ies) on x</p></li>
<li><p>sy: gaussian uncertainty(ies) on y</p></li>
<li><p>srelx: relative gaussian uncertainty(ies) on x</p></li>
<li><p>srely: relative gaussian uncertainty(ies) on y</p></li>
</ul>
</dd>
<dt>the following are common (correlated) systematic uncertainties</dt><dd><ul class="simple">
<li><p>xabscor: absolute, correlated error on x</p></li>
<li><p>yabscor: absolute, correlated error on y</p></li>
<li><p>xrelcor: relative, correlated error on x</p></li>
<li><p>yrelcor: relative, correlated error on y</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-arrays of floats:</p>
<ul>
<li><p>xtrue: true x-values</p></li>
<li><p>ytrue: true value = model(xtrue)</p></li>
<li><p>ydata:  simulated data</p></li>
</ul>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.getModelError">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">getModelError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">pvals</span></em>, <em class="sig-param"><span class="n">pcov</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.getModelError" title="Permalink to this definition">¶</a></dt>
<dd><p>determine uncertainty of model at x from parameter uncertainties</p>
<dl>
<dt>Formula: </dt><dd><p>Delta(x) = sqrt( sum_i,j (df/dp_i(x) df/dp_j(x) Vp_i,j) )</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: scalar or 1d-array of x values</p></li>
<li><p>model: model function</p></li>
<li><p>pvals: parameter values</p></li>
<li><p>covp: covariance matrix of parameters</p></li>
</ul>
<p>Returns:
* model uncertainty/ies, same length as x</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.hist2dstat">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">hist2dstat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">H2d</span></em>, <em class="sig-param"><span class="n">xed</span></em>, <em class="sig-param"><span class="n">yed</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.hist2dstat" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate statistical information from 2d Histogram</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>H2d: histogram array (as returned by histogram2d)</p></li>
<li><p>xed: bin edges in x</p></li>
<li><p>yed: bin edges in y</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: mean x</p></li>
<li><p>float: mean y</p></li>
<li><p>float: variance x</p></li>
<li><p>float: variance y</p></li>
<li><p>float: covariance of x and y</p></li>
<li><p>float: correlation of x and y</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.histstat">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">histstat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">binc</span></em>, <em class="sig-param"><span class="n">bine</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.histstat" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate mean, standard deviation and uncertainty on mean 
of a histogram with bin-contents <cite>binc</cite> and bin-edges <cite>bine</cite></p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>binc: array with bin content</p></li>
<li><p>bine: array with bin edges</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: mean, sigma and sigma on mean</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.k2Fit">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">k2Fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srely</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ref_to_model</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">limits</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['x-data', 'y-data']</span></em>, <em class="sig-param"><span class="n">data_legend</span><span class="o">=</span><span class="default_value">'data'</span></em>, <em class="sig-param"><span class="n">model_expression</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">model_legend</span><span class="o">=</span><span class="default_value">'model'</span></em>, <em class="sig-param"><span class="n">model_band</span><span class="o">=</span><span class="default_value">'$\\pm 1 \\sigma$'</span></em>, <em class="sig-param"><span class="n">fit_info</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_band</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">asym_parerrs</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_cor</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">showplots</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.k2Fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an arbitrary function func(x, *par) to data points (x, y) 
with independent and correlated absolute and/or relative errors 
on x- and y- values with package iminuit.</p>
<p>Correlated absolute and/or relative uncertainties of input data 
are specified as numpy-arrays of floats; they enter in the 
diagonal and off-diagonal elements of the covariance matrix. 
Values of 0. may be specified for data points not affected
by a correlated uncertainty. E.g. the array [0., 0., 0.5., 0.5]
results in a correlated uncertainty of 0.5 of the 3rd and 4th 
data points. Providing lists of such array permits the construction
of arbitrary covariance matrices from independent and correlated
uncertainties uncertainties of (groups of) data points.</p>
<dl>
<dt>Args:</dt><dd><ul class="simple">
<li><p>func: function to fit</p></li>
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
</ul>
<p>components of uncertainty (optional, use None if not relevant)</p>
<dl class="simple">
<dt>single float, array of length of x, or a covariance matrix</dt><dd><ul class="simple">
<li><p>sx: scalar, 1d or 2d np-array, uncertainty(ies) on x</p></li>
<li><p>sy: scalar, 1d or 2d np-array, uncertainty(ies) on y</p></li>
</ul>
</dd>
<dt>single float or array of length of x</dt><dd><ul class="simple">
<li><p>srelx: scalar or 1d np-array, relative uncertainties x</p></li>
<li><p>srely: scalar or 1d np-array, relative uncertainties y</p></li>
</ul>
</dd>
<dt>single float or array of length of x, or a list of such objects, </dt><dd><p>used to construct a covariance matrix from components</p>
<ul class="simple">
<li><p>xabscor: scalar or 1d np-array, absolute, correlated error(s) on x</p></li>
<li><p>yabscor: scalar or 1d np-array, absolute, correlated error(s) on y</p></li>
<li><p>xrelcor: scalar or 1d np-array, relative, correlated error(s) on x</p></li>
<li><p>yrelcor: scalor or 1d np-array, relative, correlated error(s) on y</p></li>
</ul>
</dd>
<dt>fit options</dt><dd><ul class="simple">
<li><p>ref_to_model, bool: refer relative errors to model if true,
else use measured data</p></li>
<li><p>p0: array-like, initial guess of parameters</p></li>
<li><p>parameter constraints: (name, value, uncertainty)</p></li>
<li><p>limits: (nested) list(s) (name, min, max)</p></li>
</ul>
</dd>
<dt>output options</dt><dd><ul class="simple">
<li><p>plot: flag to switch off graphical output</p></li>
<li><p>axis_labels: list of strings, axis labels x and y</p></li>
<li><p>data_legend: legend entry for data points</p></li>
<li><p>model_name: latex name for model function</p></li>
<li><p>model_expression: latex expression for model function</p></li>
<li><p>model_legend: legend entry for model</p></li>
<li><p>model_band: legend entry for model uncertainty band</p></li>
<li><p>fit_info: controls display of fit results on figure</p></li>
<li><p>plot_band: suppress model uncertainty-band if False</p></li>
<li><p>asym_parerrs: show (asymmetric) errors from profile-likelihood scan</p></li>
<li><p>plot_cor: show profile curves and contour lines</p></li>
<li><p>showplots: show plots on screen, default = True</p></li>
<li><p>quiet: controls text output</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of float: parameter values</p></li>
<li><p>np-array of float: parameter errors</p></li>
<li><p>np-array: cor   correlation matrix</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.kFit">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">kFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p0e</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">'Daten'</span></em>, <em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['X', 'Y']</span></em>, <em class="sig-param"><span class="n">fit_info</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.kFit" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>fit function func with errors on x and y;
uses package <cite>kafe</cite></p>
<p>!!! deprecated, consider using k2Fit() with kafe2 instead</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>func: function to fit</p></li>
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
</ul>
</dd>
<dt>the following are single floats or arrays of length of x</dt><dd><ul class="simple">
<li><p>sx: scalar or np-array, uncertainty(ies) on x</p></li>
<li><p>sy: scalar or np-array, uncertainty(ies) on y</p></li>
<li><p>p0: array-like, initial guess of parameters</p></li>
<li><p>p0e: array-like, initial guess of parameter uncertainties</p></li>
<li><p>xabscor: absolute, correlated error(s) on x</p></li>
<li><p>yabscor: absolute, correlated error(s) on y</p></li>
<li><p>xrelcor: relative, correlated error(s) on x</p></li>
<li><p>yrelcor: relative, correlated error(s) on y</p></li>
<li><p>parameter constrains (name, value, uncertainty)</p></li>
<li><p>title:   string, title of gaph</p></li>
<li><p>axis_labels: List of strings, axis labels x and y</p></li>
<li><p>parameter constraints: (name, value, uncertainty)</p></li>
<li><p>plot: flag to switch off graphical output</p></li>
<li><p>title: name of data set</p></li>
<li><p>axis labels: labels for x and y axis</p></li>
<li><p>fit info: controls display of fit results on figure</p></li>
<li><p>quiet: flag to suppress text and log output</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of float: parameter values</p></li>
<li><p>np-array of float: parameter errors</p></li>
<li><p>np-array: cor   correlation matrix</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.kRegression">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">kRegression</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">sy</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">title</span><span class="o">=</span><span class="default_value">'Daten'</span></em>, <em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['x', 'y-data']</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.kRegression" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>linear regression y(x) = ax + b  with errors on x and y;
uses package <cite>kafe</cite></p>
<p>!!! deprecated, consider using k2Fit() with linear model</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
</ul>
</dd>
<dt>the following are single floats or arrays of length of x</dt><dd><ul class="simple">
<li><p>sx: scalar or np-array, uncertainty(ies) on x</p></li>
<li><p>sy: scalar or np-array, uncertainty(ies) on y</p></li>
<li><p>xabscor: absolute, correlated error(s) on x</p></li>
<li><p>yabscor: absolute, correlated error(s) on y</p></li>
<li><p>xrelcor: relative, correlated error(s) on x</p></li>
<li><p>yrelcor: relative, correlated error(s) on y</p></li>
<li><p>title:   string, title of gaph</p></li>
<li><p>axis_labels: List of strings, axis labels x and y</p></li>
<li><p>plot: flag to switch off graphical output</p></li>
<li><p>quiet: flag to suppress text and log output</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: a     slope</p></li>
<li><p>float: b     constant</p></li>
<li><p>float: sa    sigma on slope</p></li>
<li><p>float: sb    sigma on constant</p></li>
<li><p>float: cor   correlation</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.labxParser">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">labxParser</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">prlevel</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.labxParser" title="Permalink to this definition">¶</a></dt>
<dd><p>read files in xml-format produced with Leybold CASSY</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file:  input data in .labx format</p></li>
<li><p>prlevel: control printout level, 0=no printout</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>list of strings: tags of measurmement vectors</p></li>
<li><p>2d list:         measurement vectors read from file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.linRegression">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">linRegression</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.linRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>linear regression y(x) = ax + b</p>
<dl class="simple">
<dt>method: </dt><dd><p>analytical formula</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: np-array, independent data</p></li>
<li><p>y: np-array, dependent data</p></li>
<li><p>sy: scalar or np-array, uncertainty on y</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: a     slope</p></li>
<li><p>float: b     constant</p></li>
<li><p>float: sa  sigma on slope</p></li>
<li><p>float: sb  sigma on constant</p></li>
<li><p>float: cor   correlation</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.linRegressionXY">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">linRegressionXY</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.linRegressionXY" title="Permalink to this definition">¶</a></dt>
<dd><p>linear regression y(x) = ax + b  with errors on x and y
uses numerical “orthogonal distance regression” from package scipy.odr</p>
<p>!!! deprecated, consider using odFit() with linear model instead</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
<li><p>sx: scalar or np-array, uncertainty(ies) on x</p></li>
<li><p>sy: scalar or np-array, uncertainty(ies) on y</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: a     slope</p></li>
<li><p>float: b     constant</p></li>
<li><p>float: sa    sigma on slope</p></li>
<li><p>float: sb    sigma on constant</p></li>
<li><p>float: cor   correlation</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.mFit">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">mFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fitf</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srely</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ref_to_model</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">limits</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_negLogL</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_cor</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">plot_band</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">showplots</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['x', 'y = f(x, *par)']</span></em>, <em class="sig-param"><span class="n">data_legend</span><span class="o">=</span><span class="default_value">'data'</span></em>, <em class="sig-param"><span class="n">model_legend</span><span class="o">=</span><span class="default_value">'model'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.mFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an arbitrary function fitf(x, *par) to data points (x, y) 
with independent and correlated absolute and/or relative errors on 
x- and y- values with class mnFit from package phyFit (uses iminuit).</p>
<p>Correlated absolute and/or relative uncertainties of input data 
are specified as numpy-arrays of floats; they enter in the 
diagonal and off-diagonal elements of the covariance matrix. 
Values of 0. may be specified for data points not affected
by a correlated uncertainty. E.g. the array [0., 0., 0.5., 0.5]
results in a correlated uncertainty of 0.5 of the 3rd and 4th 
data points. Providing lists of such arrays permits the construction
of arbitrary covariance matrices from independent and correlated
uncertainties of (groups of) data points.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fitf: model function to fit, arguments (float:x, float: *args)</p></li>
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
<li><p>sx: scalar or 1d or 2d np-array , uncertainties on x data</p></li>
<li><p>sy: scalar or 1d or 2d np-array , uncertainties on x data</p></li>
<li><p>srelx: scalar or np-array, relative uncertainties x</p></li>
<li><p>srely: scalar or np-array, relative uncertainties y</p></li>
<li><p>yabscor: scalar or np-array, absolute, correlated error(s) on y</p></li>
<li><p>yrelcor: scalar or np-array, relative, correlated error(s) on y</p></li>
<li><p>p0: array-like, initial guess of parameters</p></li>
<li><p>use_negLogL:  use full -2ln(L)</p></li>
<li><p>constraints: (nested) list(s) [name or id, value, error]</p></li>
<li><p>limits: (nested) list(s) [name or id, min, max]</p></li>
<li><p>plot: show data and model if True</p></li>
<li><p>plot_cor: show profile liklihoods and conficence contours</p></li>
<li><p>plot_band: plot uncertainty band around model function</p></li>
<li><p>showplots: show plots on screen, default = False</p></li>
<li><p>quiet: suppress printout</p></li>
<li><p>list of str: axis labels</p></li>
<li><p>str: legend for data</p></li>
<li><p>str: legend for model</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of float: parameter values</p></li>
<li><p>2d np-array of float: parameter uncertaities [0]: neg. and [1]: pos.</p></li>
<li><p>np-array: correlation matrix</p></li>
<li><p>float: chi2  chi-square of fit a minimum</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.meanFilter">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">meanFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">width</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.meanFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>apply a sliding average to smoothen data,</p>
<dl>
<dt>method:</dt><dd><p>value at index i and int(width/2) neighbours are averaged
to from the new value at index i</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>a: np-array of values</p></li>
<li><p>width: int, number of points to average over
(if width is an even number, width+1 is used)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>av  smoothed signal curve</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.nhist">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">nhist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">50</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">'x'</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">'frequency'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.nhist" title="Permalink to this definition">¶</a></dt>
<dd><p>Histogram.hist
show a one-dimensional histogram</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data: array containing float values to be histogrammed</p></li>
<li><p>bins: number of bins</p></li>
<li><p>xlabel: label for x-axis</p></li>
<li><p>ylabel: label for y axix</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float arrays: bin contents and bin edges</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.nhist2d">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">nhist2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">10</span></em>, <em class="sig-param"><span class="n">xlabel</span><span class="o">=</span><span class="default_value">'x axis'</span></em>, <em class="sig-param"><span class="n">ylabel</span><span class="o">=</span><span class="default_value">'y axis'</span></em>, <em class="sig-param"><span class="n">clabel</span><span class="o">=</span><span class="default_value">'counts'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.nhist2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Histrogram.hist2d
create and plot a 2-dimensional histogram</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: array containing x values to be histogrammed</p></li>
<li><p>y: array containing y values to be histogrammed</p></li>
<li><p>bins: number of bins</p></li>
<li><p>xlabel: label for x-axis</p></li>
<li><p>ylabel: label for y axix</p></li>
<li><p>clabel: label for colour index</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float array: array with counts per bin</p></li>
<li><p>float array: histogram edges in x</p></li>
<li><p>float array: histogram edges in y</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.odFit">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">odFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fitf</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.odFit" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>fit an arbitrary function with errors on x and y
uses numerical “orthogonal distance regression” from package scipy.odr</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fitf: function to fit, arguments (array:P, float:x)</p></li>
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
<li><p>sx: scalar or np-array, uncertainty(ies) on x</p></li>
<li><p>sy: scalar or np-array, uncertainty(ies) on y</p></li>
<li><p>p0: array-like, initial guess of parameters</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of float: parameter values</p></li>
<li><p>np-array of float: parameter errors</p></li>
<li><p>np-array: cor   correlation matrix</p></li>
<li><p>float: chi2  chi-square</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.offsetFilter">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">offsetFilter</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.offsetFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>correct an offset in array a 
(assuming a symmetric signal around zero)
by subtracting the mean</p>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.profile2d">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">profile2d</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">H2d</span></em>, <em class="sig-param"><span class="n">xed</span></em>, <em class="sig-param"><span class="n">yed</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.profile2d" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>generate a profile plot from 2d histogram:</dt><dd><ul class="simple">
<li><p>mean y at a centre of x-bins, standard deviations as error bars</p></li>
</ul>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>H2d: histogram array (as returned by histogram2d)</p></li>
<li><p>xed: bin edges in x</p></li>
<li><p>yed: bin edges in y</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: array of bin centres in x</p></li>
<li><p>float: array mean</p></li>
<li><p>float: array rms</p></li>
<li><p>float: array sigma on mean</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.propagatedError">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">propagatedError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="n">pvals</span></em>, <em class="sig-param"><span class="n">pcov</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.propagatedError" title="Permalink to this definition">¶</a></dt>
<dd><p>determine propageted uncertainty (with covariance matrix)</p>
<p>Formula: 
Delta = sqrt( sum_i,j (df/dp_i df/dp_j Vp_i,j) )</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>function: function of parameters pvals, 
a 1-d array is also allowed, eg. function(*p) = f(x, *p)</p></li>
<li><p>pvals: parameter values</p></li>
<li><p>pcov: covariance matrix (or uncertainties) of parameters</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>uncertainty Delta( function(*par) )</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.readCSV">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">readCSV</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">nlhead</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">delim</span><span class="o">=</span><span class="default_value">','</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.readCSV" title="Permalink to this definition">¶</a></dt>
<dd><p>read Data in .csv format, skip header lines</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>nhead: number of header lines to skip</p></li>
<li><p>delim: column separator</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>hlines: list of string, header lines</p></li>
<li><p>data: 2d array, 1st index for columns</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.readCassy">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">readCassy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">prlevel</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.readCassy" title="Permalink to this definition">¶</a></dt>
<dd><p>read Data exported from Cassy in .txt format</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>prlevel: printout level, 0 means silent</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>units: list of strings, channel units</p></li>
<li><p>data: tuple of arrays, channel data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.readColumnData">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">readColumnData</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">cchar</span><span class="o">=</span><span class="default_value">'#'</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.readColumnData" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>read column-data from file</dt><dd><ul class="simple">
<li><p>input is assumed to be columns of floats</p></li>
<li><p>characters following &lt;cchar&gt;, and &lt;cchar&gt; itself, are ignored</p></li>
<li><p>words with preceeding ‘*’ are taken as keywords for meta-data,
text following the keyword is returned in a dictionary</p></li>
</ul>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>string fnam:      file name</p></li>
<li><p>int ncols:        number of columns</p></li>
<li><p>char delimiter:   character separating columns</p></li>
<li><p>bool pr:          print input to std out if True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.readPicoScope">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">readPicoScope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">prlevel</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.readPicoScope" title="Permalink to this definition">¶</a></dt>
<dd><p>read Data exported from PicoScope in .txt or .csv format</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>prlevel: printout level, 0 means silent</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>units: list of strings, channel units</p></li>
<li><p>data: tuple of arrays, channel data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.readtxt">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">readtxt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">nlhead</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">delim</span><span class="o">=</span><span class="default_value">'\t'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.readtxt" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>read floating point data in general txt format</dt><dd><p>skip header lines, replace decimal comma, remove special characters</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>nhead: number of header lines to skip</p></li>
<li><p>delim: column separator</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>hlines: list of string, header lines</p></li>
<li><p>data: 2d array, 1st index for columns</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.resample">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">resample</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">t</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">11</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>perform average over n data points of array a, 
return reduced array, eventually with corresponding time values</p>
<dl>
<dt>method:</dt><dd><p>value at index <cite>i</cite> and <cite>int(width/2)</cite> neighbours are averaged
to from the new value at index <cite>i</cite></p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>a, t: np-arrays of values of same length</p></li>
<li><p>width: int, number of values of array <cite>a</cite> to average over
(if width is an even number, width+1 is used)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>av: array with reduced number of samples</p></li>
<li><p>tav:  a second, related array with reduced number of samples</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.round_to_error">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">round_to_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">val</span></em>, <em class="sig-param"><span class="n">err</span></em>, <em class="sig-param"><span class="n">nsd_e</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.round_to_error" title="Permalink to this definition">¶</a></dt>
<dd><p>round float <em>val</em> to corresponding number of sigfinicant digits  
as uncertainty <em>err</em></p>
<dl class="simple">
<dt>Arguments:</dt><dd><ul class="simple">
<li><p>val, float: value</p></li>
<li><p>err, float: uncertainty of value</p></li>
<li><p>nsd_e, int: number of significant digits of err</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>int:   number of significant digits for v</p></li>
<li><p>float: val rounded to precision of err</p></li>
<li><p>float: err rounded to precision nsd_e</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.simplePeakfinder">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">simplePeakfinder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">th</span><span class="o">=</span><span class="default_value">0.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.simplePeakfinder" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>find positions of all maxima (peaks) in data</dt><dd><p>x-coordinates are determined from weighted average over 3 data points</p>
</dd>
<dt>this only works for very smooth data with well defined extrema</dt><dd><p>use <code class="docutils literal notranslate"><span class="pre">convolutionPeakfinder</span></code> or <code class="docutils literal notranslate"><span class="pre">scipy.signal.argrelmax()</span></code> instead</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: np-array of positions</p></li>
<li><p>a: np-array of values at positions x</p></li>
<li><p>th: float, threshold for peaks</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array: x positions of peaks as weighted mean over neighbours</p></li>
<li><p>np-array: y values correspoding to peaks</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.smearData">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">smearData</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">d</span></em>, <em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">srel</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">abscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">relcor</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.smearData" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate measurement data from “true” input 
by adding random deviations according to the uncertainties</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>d:  np-array, (true) input data</p></li>
</ul>
</dd>
<dt>the following are single floats or arrays of length of array d</dt><dd><ul class="simple">
<li><p>s: gaussian uncertainty(ies) (absolute)</p></li>
<li><p>srel: gaussian uncertainties (relative)</p></li>
</ul>
</dd>
<dt>the following are common (correlated) systematic uncertainties</dt><dd><ul class="simple">
<li><p>abscor: 1d np-array of floats or list of np-arrays:
absolute correlated uncertainties</p></li>
<li><p>relcor: 1d np-array of floats or list of np-arrays:
relative correlated uncertainties</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of floats: dm, smeared (=measured) data</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.ustring">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">ustring</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">e</span></em>, <em class="sig-param"><span class="n">pe</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.ustring" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>v +/- e as formatted string </dt><dd><p>with number of significant digits corresponding to 
precision pe of uncertainty</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>v: value</p></li>
<li><p>e: uncertrainty</p></li>
<li><p>pe: precision (=number of significant digits) of uncertainty</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>string: &lt;v&gt; +/- &lt;e&gt; with appropriate number of digits</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.wmean">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">wmean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">sx</span></em>, <em class="sig-param"><span class="n">V</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">pr</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.wmean" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>weighted mean of np-array x with uncertainties sx </dt><dd><p>or covariance matrix V; if both are given, sx**2 is added 
to the diagonal elements of the covariance matrix</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: np-array of values</p></li>
<li><p>sx: np-array uncertainties</p></li>
<li><p>V: optional, covariance matrix of x</p></li>
<li><p>pr: if True, print result</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>float: mean, sigma</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.writeCSV">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">writeCSV</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">ldata</span></em>, <em class="sig-param"><span class="n">hlines</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">fmt</span><span class="o">=</span><span class="default_value">'%.10g'</span></em>, <em class="sig-param"><span class="n">delim</span><span class="o">=</span><span class="default_value">','</span></em>, <em class="sig-param"><span class="n">nline</span><span class="o">=</span><span class="default_value">'\n'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.writeCSV" title="Permalink to this definition">¶</a></dt>
<dd><p>write data in .csv format, including header lines</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>ldata: list of columns to be written</p></li>
<li><p>hlines: list with header lines (optional)</p></li>
<li><p>fmt: format string (optional)</p></li>
<li><p>delim: delimiter to seperate values (default comma)</p></li>
<li><p>nline: newline string</p></li>
</ul>
</dd>
<dt>Returns: </dt><dd><ul class="simple">
<li><p>0/1  for success/fail</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="PhyPraKit.writeTexTable">
<code class="sig-prename descclassname">PhyPraKit.</code><code class="sig-name descname">writeTexTable</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">file</span></em>, <em class="sig-param"><span class="n">ldata</span></em>, <em class="sig-param"><span class="n">cnames</span><span class="o">=</span><span class="default_value">[]</span></em>, <em class="sig-param"><span class="n">caption</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">fmt</span><span class="o">=</span><span class="default_value">'%.10g'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.writeTexTable" title="Permalink to this definition">¶</a></dt>
<dd><p>write data formatted as latex tabular</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>file: string, file name</p></li>
<li><p>ldata: list of columns to be written</p></li>
<li><p>cnames: list of column names (optional)</p></li>
<li><p>caption: LaTeX table caption (optional)</p></li>
<li><p>fmt: format string (optional)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>0/1 for success/fail</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<span class="target" id="module-PhyPraKit.phyFit"></span><p>package phyFit.py</p>
<blockquote>
<div><p>Physics Fitting with <cite>iminiut</cite> [<a class="reference external" href="https://iminuit.readthedocs.ios/en/stable/">https://iminuit.readthedocs.ios/en/stable/</a>]</p>
<p>Author: Guenter Quast, initial version Jan. 2021</p>
<dl class="simple">
<dt>Requirements: </dt><dd><ul class="simple">
<li><p>Python &gt;= 3.6</p></li>
<li><p>supports iminuit vers. &lt; 2 and &gt;= 2.</p></li>
<li><p>scipy &gt; 1.5.0</p></li>
<li><p>matplotlib &gt; 3</p></li>
</ul>
</dd>
</dl>
<p>The class <cite>mnFit.py</cite> uses the package <cite>iminuit</cite> for fitting 
a parameter-dependent model  f(x, *par) to data points (x, y)
with independent and/or correlated absolute and/or 
relative uncertainties in the x and/or y directions. 
An example function mFit() illustrates how to control the 
interface of <cite>mnFit</cite>, and a short script is provided to 
perform a fit on sample data.</p>
<dl class="simple">
<dt>Method:</dt><dd><p>A user-defined cost function in <cite>iminuit</cite> with uncertainties 
that depend on model parameters is dynamically updated during 
the fitting process. Data points with relative errors can thus
be referred to the model instead of the data. The derivative
of the model function w.r.t. x is used to project the 
covariance matrix of x-uncertainties on the y-axis.</p>
</dd>
</dl>
<p>The implementation in this example is minimalistic and
intended to illustrate the principle of an advanced usage
of <cite>iminuit</cite>. It is also meant to stimulate own studies with 
special, user-defined cost functions.</p>
<dl class="simple">
<dt>The main features of this package are:</dt><dd><ul class="simple">
<li><p>definition of a custom cost function</p></li>
<li><p>implementation of the least squares method with correlated errors</p></li>
<li><p>support for correlated x-uncertainties by projection on the y-axis</p></li>
<li><p>support of relative errors with reference to the model values</p></li>
<li><p>evaluation of profile likelihoods to determine asymetric uncertainties</p></li>
<li><p>plotting of profile likeliood and confidence contours</p></li>
</ul>
</dd>
</dl>
<p>The <strong>cost function</strong> that is optimized is a least-squares one, or an 
extended version if parameter-dependent uncertainties are present. In 
the latter case,  the logarithm of the determinant of the covariance 
matrix is added to the least-squares cost function, so that it corresponds 
to twice the negative log-likelihood of a multivariate Gaussian distribution.</p>
<p>A fully functional example is provided by the function <cite>mFit()</cite> and
the executable script below, which contains sample data, executes the
fitting procecure and collects the results.</p>
</div></blockquote>
<dl class="py function">
<dt id="PhyPraKit.phyFit.mFit">
<code class="sig-prename descclassname">PhyPraKit.phyFit.</code><code class="sig-name descname">mFit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">fitf</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">sx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">srely</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">xrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yabscor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">yrelcor</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ref_to_model</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">limits</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_negLogL</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_cor</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">showplots</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">plot_band</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['x', 'y = f(x, *par)']</span></em>, <em class="sig-param"><span class="n">data_legend</span><span class="o">=</span><span class="default_value">'data'</span></em>, <em class="sig-param"><span class="n">model_legend</span><span class="o">=</span><span class="default_value">'model'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mFit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit an arbitrary function fitf(x, *par) to data points (x, y) 
with independent and/or correlated absolute and/or relative errors 
on x- and/or y- values with class mnFit using the package iminuit.</p>
<p>Correlated absolute and/or relative uncertainties of input data 
are specified as floats (if all uncertainties are equal) or as 
numpy-arrays of floats. The concept of independent or common 
uncertainties of (groups) of data points is used construct the 
full covariance matrix from different uncertainty components.
Indepenent uncertainties enter only in the diagonal, while correlated 
ones contribute to diagonal and off-diagonal elements of the covariance 
matrix. Values of 0. may be specified for data points not affected by a 
certrain type of uncertainty. E.g. the array [0., 0., 0.5., 0.5] specifies
uncertainties only affecting the 3rd and 4th data points. Providing lists 
of such arrays permits the construction of arbitrary covariance matrices 
from independent and correlated uncertainties of (groups of) data points.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fitf: model function to fit, arguments (float:x, float: *args)</p></li>
<li><p>x:  np-array, independent data</p></li>
<li><p>y:  np-array, dependent data</p></li>
<li><p>sx: scalar or 1d or 2d np-array , uncertainties on x data</p></li>
<li><p>sy: scalar or 1d or 2d np-array , uncertainties on x data</p></li>
<li><p>srelx: scalar or np-array, relative uncertainties x</p></li>
<li><p>srely: scalar or np-array, relative uncertainties y</p></li>
<li><p>yabscor: scalar or np-array, absolute, correlated error(s) on y</p></li>
<li><p>yrelcor: scalar or np-array, relative, correlated error(s) on y</p></li>
<li><p>p0: array-like, initial guess of parameters</p></li>
<li><p>use_negLogL:  use full -2ln(L)</p></li>
<li><p>constraints: (nested) list(s) [name or id, value, error]</p></li>
<li><p>limits: (nested) list(s) [name or id, min, max]</p></li>
<li><p>plot: show data and model if True</p></li>
<li><p>plot_cor: show profile liklihoods and conficence contours</p></li>
<li><p>plot_band: plot uncertainty band around model function</p></li>
<li><p>quiet: suppress printout</p></li>
<li><p>list of str: axis labels</p></li>
<li><p>str: legend for data</p></li>
<li><p>str: legend for model</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>np-array of float: parameter values</p></li>
<li><p>2d np-array of float: parameter uncertaities [0]: neg. and [1]: pos.</p></li>
<li><p>np-array: correlation matrix</p></li>
<li><p>float: chi2  chi-square of fit a minimum</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="PhyPraKit.phyFit.mnFit">
<em class="property">class </em><code class="sig-prename descclassname">PhyPraKit.phyFit.</code><code class="sig-name descname">mnFit</code><a class="headerlink" href="#PhyPraKit.phyFit.mnFit" title="Permalink to this definition">¶</a></dt>
<dd><p><strong>Fit an arbitrary funtion f(x, *par) to data</strong>  
with independent and/or correlated absolute and/or relative uncertainties</p>
<p>This implementation depends on and heavily uses features of 
the minimizer <strong>iminuit</strong>.</p>
<p>Public methods:</p>
<ul class="simple">
<li><p>init_data():        initialze data and uncertainties</p></li>
<li><p>init_fit():         initialize fit: data, model and parameter constraints</p></li>
<li><p>setOptions():       set options for mnFit</p></li>
<li><p>do_fit():           perform fit</p></li>
<li><p>plotModel():        plot model function and data</p></li>
<li><p>plotContours():     plot profile likelihoods and confidence contours</p></li>
<li><p>getResult():        access to final fit results</p></li>
<li><p>getFunctionError(): uncertainty of model at point(s) x for parameters p</p></li>
<li><p>plot_Profile():     plot profile Likelihood for parameter</p></li>
<li><p>plot_clContour():   plot confidence level coutour for pair of parameters</p></li>
<li><p>plot_nsigContour(): plot n-sigma coutours for pair of parameters</p></li>
</ul>
<p>Public data members:</p>
<ul class="simple">
<li><p>ParameterNames:     names of parameters (as specified in model function)</p></li>
<li><p>Chi2:               chi2 at best-fit point</p></li>
<li><p>NDoF:               number of degrees of freedom</p></li>
<li><p>ParameterValues:    parameter values at best-fit point</p></li>
<li><p>MigradErrors:       symmetric uncertainties</p></li>
<li><p>CovarianceMatrix:   covariance matrix</p></li>
<li><p>CorrelationMatrix:  correlation matrix</p></li>
<li><p>OneSigInterval:     one-sigma (68% CL) ranges of parameer values</p></li>
<li><p>covx:     covariance matrix of x-data</p></li>
<li><p>covy:     covariance matrix of y-data</p></li>
<li><p>cov:      combined covariance matrix, including projected x-uncertainties</p></li>
</ul>
<p>Instances of sub-classes:</p>
<ul class="simple">
<li><p>minuit.*: methods and members of Minuit object</p></li>
<li><p>data.*:   methods and members of sub-class DataUncertainties</p></li>
<li><p>costf.*:  methods and members of sub-class xLSQ</p></li>
</ul>
<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.CL2Chi2">
<em class="property">static </em><code class="sig-name descname">CL2Chi2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">CL</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.CL2Chi2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate DeltaChi2 from confidence level CL</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.Chi22CL">
<em class="property">static </em><code class="sig-name descname">Chi22CL</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dc2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.Chi22CL" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate confidence level CL from DeltaChi2</p>
</dd></dl>

<dl class="py class">
<dt id="PhyPraKit.phyFit.mnFit.DataUncertainties">
<em class="property">class </em><code class="sig-name descname">DataUncertainties</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">ex</span></em>, <em class="sig-param"><span class="n">ey</span></em>, <em class="sig-param"><span class="n">erelx</span></em>, <em class="sig-param"><span class="n">erely</span></em>, <em class="sig-param"><span class="n">cabsx</span></em>, <em class="sig-param"><span class="n">crelx</span></em>, <em class="sig-param"><span class="n">cabsy</span></em>, <em class="sig-param"><span class="n">crely</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.DataUncertainties" title="Permalink to this definition">¶</a></dt>
<dd><p>Handle data and uncertainties, 
build covariance matrices from components</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>outer:   pointer to instance of calling object</p></li>
<li><p>x:       abscissa of data points (“x values”)</p></li>
<li><p>y:       ordinate of data points (“y values”)</p></li>
<li><p>ex:      independent uncertainties x</p></li>
<li><p>ey:      independent uncertainties y</p></li>
<li><p>erelx:   independent relative uncertainties x</p></li>
<li><p>erely:   independent relative uncertainties y</p></li>
<li><p>cabsx:   correlated abolute uncertainties x</p></li>
<li><p>crelx:   correlated relative uncertainties x</p></li>
<li><p>cabsy:   correlated absolute uncertainties y</p></li>
<li><p>crely:   correlated relative uncertainties y</p></li>
<li><p>quiet:   no informative printout if True</p></li>
</ul>
</dd>
<dt>Public methods:</dt><dd><ul class="simple">
<li><p>get_Cov(): final covariance matrix (incl. proj. x)</p></li>
<li><p>get_xCov(): covariance of x-values</p></li>
<li><p>get_yCov(): covariance of y-values</p></li>
<li><p>get_iCov(): inverse covariance matrix</p></li>
</ul>
</dd>
<dt>Data members:  </dt><dd><ul class="simple">
<li><p>copy of all input arguments</p></li>
<li><p>covx: covariance matrix of x</p></li>
<li><p>covy: covariance matrix of y uncertainties</p></li>
<li><p>cov: full covariance matrix incl. projected x</p></li>
<li><p>iCov: inverse of covariance matrix</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.DataUncertainties.get_Cov">
<code class="sig-name descname">get_Cov</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.DataUncertainties.get_Cov" title="Permalink to this definition">¶</a></dt>
<dd><p>return covariance matrix of data</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.DataUncertainties.get_iCov">
<code class="sig-name descname">get_iCov</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.DataUncertainties.get_iCov" title="Permalink to this definition">¶</a></dt>
<dd><p>return inverse of covariance matrix, as used in cost function</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.DataUncertainties.get_xCov">
<code class="sig-name descname">get_xCov</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.DataUncertainties.get_xCov" title="Permalink to this definition">¶</a></dt>
<dd><p>return covariance matrix of x-data</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.DataUncertainties.get_yCov">
<code class="sig-name descname">get_yCov</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.DataUncertainties.get_yCov" title="Permalink to this definition">¶</a></dt>
<dd><p>return covariance matrix of y-data</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.chi2prb">
<em class="property">static </em><code class="sig-name descname">chi2prb</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">chi2</span></em>, <em class="sig-param"><span class="n">ndof</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.chi2prb" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate chi2-probability from chi2 and degrees of freedom</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.do_fit">
<code class="sig-name descname">do_fit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.do_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>perform all necessary steps of fitting sequence</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.getFunctionError">
<em class="property">static </em><code class="sig-name descname">getFunctionError</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">pvals</span></em>, <em class="sig-param"><span class="n">covp</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.getFunctionError" title="Permalink to this definition">¶</a></dt>
<dd><p>determine error of model at x</p>
<p>Formula: 
Delta(x) = sqrt( sum_i,j (df/dp_i(x) df/dp_j(x) Vp_i,j) )</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x: scalar or np-array of x values</p></li>
<li><p>model: model function</p></li>
<li><p>pvlas: parameter values</p></li>
<li><p>covp: covariance matrix of parameters</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>model uncertainty, same length as x</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.getResult">
<code class="sig-name descname">getResult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.getResult" title="Permalink to this definition">¶</a></dt>
<dd><p>return most im portant results as numpy arrays</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.get_functionSignature">
<em class="property">static </em><code class="sig-name descname">get_functionSignature</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">f</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.get_functionSignature" title="Permalink to this definition">¶</a></dt>
<dd><p>get arguments and keyword arguments passed to a function</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.init_data">
<code class="sig-name descname">init_data</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">y</span></em>, <em class="sig-param"><span class="n">ex</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ey</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">erelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">erely</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cabsx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">crelx</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cabsy</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">crely</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize data object</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>x:       abscissa of data points (“x values”)</p></li>
<li><p>y:       ordinate of data points (“y values”)</p></li>
<li><p>ex:      independent uncertainties x</p></li>
<li><p>ey:      independent uncertainties y</p></li>
<li><p>erelx:   independent relative uncertainties x</p></li>
<li><p>erely:   independent relative uncertainties y</p></li>
<li><p>cabsx:   correlated abolute uncertainties x</p></li>
<li><p>crelx:   correlated relative uncertainties x</p></li>
<li><p>cabsy:   correlated absolute uncertainties y</p></li>
<li><p>crely:   correlated relative uncertainties y</p></li>
<li><p>quiet:   no informative printout if True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.init_fit">
<code class="sig-name descname">init_fit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">p0</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">constraints</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">limits</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.init_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize fit object</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>model: model function f(x; *par)</p></li>
<li><p>p0: np-array of floats, initial parameter values</p></li>
<li><p>constraints: (nested) list(s): [parameter name, value, uncertainty] 
or [parameter index, value, uncertainty]</p></li>
<li><p>limits: (nested) list(s): [parameter name, min, max] 
or [parameter index, min, max]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.plotContours">
<code class="sig-name descname">plotContours</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.plotContours" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot grid of profile curves and one- and two-sigma
contour lines from iminuit object</p>
<dl class="simple">
<dt>Arg: </dt><dd><ul class="simple">
<li><p>iminuitObject</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>matplotlib figure</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.plotModel">
<code class="sig-name descname">plotModel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">axis_labels</span><span class="o">=</span><span class="default_value">['x', 'y = f(x, *par)']</span></em>, <em class="sig-param"><span class="n">data_legend</span><span class="o">=</span><span class="default_value">'data'</span></em>, <em class="sig-param"><span class="n">model_legend</span><span class="o">=</span><span class="default_value">'fit'</span></em>, <em class="sig-param"><span class="n">plot_band</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.plotModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot model function and data</p>
<p>Uses iminuitObject abd cost Fuction of type LSQwithCov</p>
<dl class="simple">
<dt>Args: </dt><dd><ul class="simple">
<li><p>list of str: axis labels</p></li>
<li><p>str: legend for data</p></li>
<li><p>str: legend for model</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>matplotlib figure</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.plot_Profile">
<code class="sig-name descname">plot_Profile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pnam</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.plot_Profile" title="Permalink to this definition">¶</a></dt>
<dd><p>plot profile likelihood of parameter pnam</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.plot_clContour">
<code class="sig-name descname">plot_clContour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pnam1</span></em>, <em class="sig-param"><span class="n">pnam2</span></em>, <em class="sig-param"><span class="n">cl</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.plot_clContour" title="Permalink to this definition">¶</a></dt>
<dd><p>plot a contour of parameters pnam1 and pnam2
with confidence level(s) cl</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.plot_nsigContour">
<code class="sig-name descname">plot_nsigContour</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pnam1</span></em>, <em class="sig-param"><span class="n">pnam2</span></em>, <em class="sig-param"><span class="n">nsig</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.plot_nsigContour" title="Permalink to this definition">¶</a></dt>
<dd><p>plot nsig contours of parameters pnam1 and pnam2</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.round_to_error">
<em class="property">static </em><code class="sig-name descname">round_to_error</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">val</span></em>, <em class="sig-param"><span class="n">err</span></em>, <em class="sig-param"><span class="n">nsd_e</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.round_to_error" title="Permalink to this definition">¶</a></dt>
<dd><p>round float <em>val</em> to same number of sigfinicant digits as uncertainty <em>err</em></p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>int:   number of significant digits for v</p></li>
<li><p>float: val rounded to precision of err</p></li>
<li><p>float: err rounded to precision nsd_e</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.setLimits">
<code class="sig-name descname">setLimits</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">limits</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.setLimits" title="Permalink to this definition">¶</a></dt>
<dd><p>store parameter limits</p>
<p>format: nested list(s) of type 
[parameter name, min, max] or
[parameter index, min, max]</p>
</dd></dl>

<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.setOptions">
<code class="sig-name descname">setOptions</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">relative_refers_to_model</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">run_minos</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_negLogL</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.setOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Define mnFit options</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>rel. errors refer to model else data</p></li>
<li><p>run minos else don*t run minos</p></li>
<li><p>use full neg2logL</p></li>
<li><p>don*t provide printout else verbose printout</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt id="PhyPraKit.phyFit.mnFit.xLSQ">
<em class="property">class </em><code class="sig-name descname">xLSQ</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">outer</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">model</span></em>, <em class="sig-param"><span class="n">use_neg2logL</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">quiet</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.xLSQ" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Custom e_x_tended Least-SQuares cost function with 
dynamically updated covariance matrix and -2log(L) 
correction term for parameter-dependent uncertainties</p>
<p>For data points (x, y) with model f(x, *p) 
and covariance matrix V(f(x,*p)
the cost function is:</p>
<div class="math notranslate nohighlight">
\[-2\ln {\cal L} = \chi^2(y, V^{-1}, f(x, *p) \,) 
+ \ln(\, \det( V(f(x, *p) ) \,)\]</div>
<p>For uncertainties depending on the model parameters, a more
efficient approach is used to calculate the likelihood, which
uses the Cholesky decompostion of the covariance matrix into a
product of a triangular matrix and its transposed</p>
<div class="math notranslate nohighlight">
\[V = L L^T,\]</div>
<p>thus avoiding the costy calculation of the inverse matrix.</p>
<div class="math notranslate nohighlight">
\[\chi^2 = {r}\cdot (V^{-1}{r}) ~~with~~ r = y - f(x,*p)\]</div>
<p>is obtained by solving the linear equation</p>
</div></blockquote>
<div class="math notranslate nohighlight">
\[V X = r, ~i.e.~ X=V^{-1} r ~and~ \chi^2= r \cdot X   \]</div>
<p>with the effecient linear-equation solver <em>scipy.linalg.cho_solve(L,x)</em>
for Cholesky-decomposed matrices.</p>
<p>The determinant is efficiently calculated by taking the product 
of the diagonal elements of the matrix L,</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\det(V) = 2 \, \prod L_{i,i}\]</div>
<p>Input:</p>
<ul class="simple">
<li><p>outer: pointer to instance of calling class</p></li>
<li><p>data: data object of type DataUncertainties</p></li>
<li><p>model: model function f(x, *par)</p></li>
<li><p>use_neg2logL: use full -2log(L) instead of chi2 if True</p></li>
</ul>
<p>__call__ method of this class is called by iminuit</p>
<p>Data members:</p>
<ul class="simple">
<li><p>ndof: degrees of freedom</p></li>
<li><p>nconstraints: number of parameter constraints</p></li>
<li><p>chi2: chi2-value (goodness of fit)</p></li>
<li><p>use_neg2logL: usage of full 2*neg Log Likelihood</p></li>
<li><p>quiet: no printpout if True</p></li>
</ul>
<p>Methods:</p>
<ul class="simple">
<li><p>model(x, *par)</p></li>
</ul>
</div></blockquote>
<dl class="py method">
<dt id="PhyPraKit.phyFit.mnFit.xLSQ.setConstraints">
<code class="sig-name descname">setConstraints</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">constraints</span></em><span class="sig-paren">)</span><a class="headerlink" href="#PhyPraKit.phyFit.mnFit.xLSQ.setConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Add parameter constraints</p>
<p>format: nested list(s) of type 
[parameter name, value, uncertainty] or
[parameter index, value, uncertainty]</p>
</dd></dl>

</dd></dl>

</dd></dl>

<span class="target" id="module-test_readColumnData"></span><dl class="simple">
<dt>test_readColumnData.py</dt><dd><p>test data input from text file with module PhyPraKit.readColumnData</p>
</dd>
</dl>
<span class="target" id="module-test_readtxt"></span><dl class="simple">
<dt>test_readtxt.py </dt><dd><p>uses readtxt() to read floating-point column-data in very general 
.txt formats, here the output from PicoTech 8 channel data logger,
with ‘       ‘ separated values, 2 header lines,
german decimal comma and special character ‘^&#64;’</p>
</dd>
</dl>
<span class="target" id="module-test_readPicoScope"></span><dl class="simple">
<dt>test_readPicoSocpe.py </dt><dd><p>read data exported by PicoScope usb-oscilloscope</p>
</dd>
</dl>
<span class="target" id="module-test_labxParser"></span><dl class="simple">
<dt>test_labxParser.py</dt><dd><p>read files in xml-format produced with the Leybold Cassy system  
uses PhyPraPit.labxParser()</p>
</dd>
</dl>
<span class="target" id="module-test_Histogram"></span><dl class="simple">
<dt>test_Historgram.py</dt><dd><p>demonstrate histogram functionality in PhyPraKit</p>
</dd>
</dl>
<span class="target" id="module-test_convolutionFilter"></span><dl>
<dt>test_convolutionFilter.py </dt><dd><p>Read data exported with PicoScope usb-oscilloscpe,
here the accoustic excitation of a steel rod</p>
<p>Demonstrates usage of convolutionFilter for detection
of signal maxima and falling edges</p>
</dd>
</dl>
<span class="target" id="module-test_AutoCorrelation"></span><dl>
<dt>test_AutoCorrelation.py</dt><dd><p>test function <cite>autocorrelate()</cite> in PhyPraKit; 
determines the frequency of a periodic signal from maxima and minima
of the autocorrelation function and performs statistical analysis
of time between peaks/dips</p>
<p>uses <cite>readCSV()</cite>, <cite>autocorrelate()</cite>, <cite>convolutionPeakfinder()</cite> 
and <cite>histstat()</cite> from PhyPraKit</p>
</dd>
</dl>
<span class="target" id="module-test_Fourier"></span><dl>
<dt>test_Fourier.py </dt><dd><p>Read data exported with PicoScope usb-oscilloscpe,
here the accoustic excitation of a steel rod</p>
<p>Demonstraion of a Fourier transformation of the signal</p>
</dd>
</dl>
<span class="target" id="module-test_propagatedError"></span><dl class="simple">
<dt>test_propagatedError.py</dt><dd><p>Beispiel: Numerische Fehlerfortpflanzung mit PhyPraKit.prpagatedError()
Illustriert auch die Verwendung der Rundung auf die Genauigkeit der
Unsicherheit.</p>
</dd>
</dl>
<span class="target" id="module-test_kRegression"></span><dl class="simple">
<dt>test_kRegression</dt><dd><p>test linear regression with kafe using kFit from PhyPrakKit
uncertainties in x and y and correlated 
absolute and relative uncertainties</p>
</dd>
</dl>
<span class="target" id="module-test_odFit"></span><dl class="simple">
<dt>test_odFit</dt><dd><p>test fitting an arbitrary fucntion with scipy odr, 
with uncertainties in x and y</p>
</dd>
</dl>
<span class="target" id="module-test_mFit"></span><dl>
<dt>test_mFit.py</dt><dd><p>Fitting example with iminiut</p>
<p>Uses function PhyPraKit.mFit, which in turn uses mnFit from phyFit</p>
<p>This is a rather complete example showing a fit to
data with independent and correlated, absolute and 
relative uncertainties in the x and y directions.</p>
</dd>
</dl>
<span class="target" id="module-test_kFit"></span><dl class="simple">
<dt>test_kFit</dt><dd><p>test fitting an arbitrary function with kafe, 
with uncertainties in x and y and correlated 
absolute and relative uncertainties</p>
</dd>
</dl>
<span class="target" id="module-test_k2Fit"></span><dl class="simple">
<dt>test_k2Fit</dt><dd><p>Illustrate fitting of an arbitrary function with kafe2  
This example illustrates the special features of kafe2:
- correlated errors for x and y data  
- relative errors with reference to model
- profile likelihood method to evaluate asymmetric errors
- plotting of profile likeliood and confidence contours</p>
</dd>
</dl>
<span class="target" id="module-test_generateData"></span><dl class="simple">
<dt>test_generateData</dt><dd><p>test generation of simulated data
this simulates a measurement with given x-values with uncertainties;
random deviations are then added to arrive at the true values, from
which the true y-values are then calculated according to a model
function. In the last step, these true y-values are smeared
by adding random deviations to obtain a sample of measured values</p>
</dd>
</dl>
<span class="target" id="module-toyMC_Fit"></span><dl>
<dt>toyMC_Fit.py</dt><dd><p>run a large number of fits on toyMC data
to check for biases and chi2-probability distribution</p>
<p>This rather complete example uses eight different kinds of uncertainties, 
namely independent and correlated, absolute and relative ones  
in the x and y directions.</p>
</dd>
</dl>
<span class="target" id="module-kfitf"></span><dl>
<dt>kfitf.py  </dt><dd><p>Perform a fit with the kafe package driven by input file</p>
<p>usage: kfitf.py [-h] [-n] [-s] [-c] [–noinfo] [-f FORMAT] filename</p>
<dl>
<dt>positional arguments:</dt><dd><p>filename                       name of fit input file</p>
</dd>
<dt>optional arguments:</dt><dd><dl class="option-list">
<dt><kbd><span class="option">-h</span>, <span class="option">--help</span></kbd></dt>
<dd><p>show this help message and exit</p>
</dd>
<dt><kbd><span class="option">-n</span>, <span class="option">--noplot</span></kbd></dt>
<dd><p>suppress ouput of plots on screen</p>
</dd>
<dt><kbd><span class="option">-s</span>, <span class="option">--saveplot</span></kbd></dt>
<dd><p>save plot(s) in file(s)</p>
</dd>
<dt><kbd><span class="option">-c</span>, <span class="option">--contour</span></kbd></dt>
<dd><p>plot contours and profiles</p>
</dd>
<dt><kbd><span class="option">--noinfo</span></kbd></dt>
<dd><p>suppress fit info on plot</p>
</dd>
<dt><kbd><span class="option">--noband</span></kbd></dt>
<dd><p>suppress 1-sigma band around function</p>
</dd>
<dt><kbd><span class="option">--format <var>FMT</var></span></kbd></dt>
<dd><p>graphics output format, default FMT = pdf</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<span class="target" id="module-Beispiel_Diodenkennlinie"></span><dl class="simple">
<dt>Beispiel_Diodenkennlinie.py</dt><dd><p>Messung einer Strom-Spannungskennlinie und Anpassung der Schockley-Gleichung.</p>
<ul class="simple">
<li><p>Konstruktion der Kovarianzmatrix für reale Messinstrumente mit 
Signalrauschen, Anzeigeunsicherheiten und korrelierten, realtiven 
Kalibratsionsunsicherheiten für die Strom- und Spannungsmessung.</p></li>
<li><p>Ausführen der Anpassung der Shockley-Gleichung mit <em>k2Fit</em> oder <em>mFit</em> 
aus dem Paket <em>PhyPraKit</em>. Wichtig: die Modellfunktion ist nicht 
nach oben beschränkt, sondern divergiert sehr schnell. Daher muss der 
verwendete numerische Optimierer Parameterlimits unterstützen.</p></li>
</ul>
</dd>
</dl>
<span class="target" id="module-Beispiel_Drehpendel"></span><dl class="simple">
<dt>Beispiel_Drehpendel.py  </dt><dd><p>Auswertung der Daten aus einer im CASSY labx-Format gespeicherten Datei
am Beispiel des Drehpendels</p>
<ul class="simple">
<li><p>Einlesen der Daten im .labx-Format</p></li>
<li><p>Säubern der Daten durch verschiedene Filterfunktionen:
- offset-Korrektur
- Glättung durch gleitenden Mittelwert
- Zusammenfassung benachberter Daten durch Mittelung</p></li>
<li><p>Fourier-Transformation (einfach und fft)</p></li>
<li><p>Suche nach Extrema (<cite>peaks</cite> und <cite>dips</cite>)</p></li>
<li><p>Anpassung von Funkionen an Einhüllende der Maxima und Minima</p></li>
<li><p>Interpolation durch Spline-Funktionen</p></li>
<li><p>numerische Ableitung und Ableitung der Splines</p></li>
<li><p>Phasenraum-Darstellung (aufgezeichnete Wellenfunktion
gegen deren Ableitung nach der Zeit)</p></li>
</ul>
</dd>
</dl>
<span class="target" id="module-Beispiel_Hysterese"></span><dl class="simple">
<dt>Beispiel_Hysterese.py </dt><dd><p>Auswertung der Daten aus einer mit PicoScope erstellten Datei
im txt-Format am Beispiel des Hystereseversuchs</p>
<ul class="simple">
<li><p>Einlesen der Daten aus PicoScope-Datei vom Typ .txt oder .csv</p></li>
<li><p>Darstellung  Kanal_a vs. Kanal_b</p></li>
<li><p>Auftrennung in zwei Zweige für steigenden bzw. abnehmenden Strom</p></li>
<li><p>Interpolation durch kubische Splines</p></li>
<li><p>Integration der Spline-Funktionen</p></li>
</ul>
</dd>
</dl>
<span class="target" id="module-Beispiel_Wellenform"></span><dl class="simple">
<dt>Beispiel_Wellenform.py </dt><dd><p>Einlesen von Daten aus dem mit PicoScope erstellten Dateien
am Beispiel der akustischen Anregung eines Stabes</p>
<ul class="simple">
<li><p>Fourier-Analyse des Signals</p></li>
<li><p>Bestimmung der Resonanzfrequenz mittels Autokorrelation</p></li>
</ul>
</dd>
</dl>
<span class="target" id="module-Beispiel_GammaSpektroskopie"></span><dl class="simple">
<dt>Beispiel_GammaSpektroskopie.py </dt><dd><p>Darstellung der Daten aus einer im CASSY labx-Format gespeicherten Datei
am Beispiel der Gamma-Spektroskopie</p>
<ul class="simple">
<li><p>Einlesen der Daten im .labx-Format</p></li>
</ul>
</dd>
</dl>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><strong>PhyPraKit Documentation</strong></a><ul>
<li><a class="reference internal" href="#about">About</a><ul>
<li><a class="reference internal" href="#installation">Installation:</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#visualisation-and-analysis-of-measurement-data"><strong>Visualisation and Analysis of Measurement Data</strong></a></li>
<li><a class="reference internal" href="#dokumentation-der-beispiele">Dokumentation der Beispiele</a></li>
<li><a class="reference internal" href="#module-PhyPraKit">Module Documentation</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">PhyPraKit 1.1.3 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>PhyPraKit Documentation</strong></a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Günter Quast.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>